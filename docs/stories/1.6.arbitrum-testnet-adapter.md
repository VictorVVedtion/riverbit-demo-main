# Story 1.6: Arbitrum测试网适配占位

## Status
Approved

## Story
**As a** 全栈开发者,
**I want** 配置 MetaMask 连接并实现最小资产桥接合约,
**so that** 用户可以通过 Arbitrum 测试网入金/出金 USDC。

## Acceptance Criteria
1. MetaMask 集成完成,支持连接 Arbitrum Sepolia 测试网
2. 最小资产桥接合约部署 (`BridgeAdapter.sol`)
3. 入金/出金 UI 占位组件实现
4. Hardhat 测试框架配置完成
5. 桥接流程可端到端测试 (Arbitrum → RiverChain → Arbitrum)

## Tasks / Subtasks

- [ ] Task 1: 集成 MetaMask (AC: 1)
  - [ ] 实现 `useMetaMask` Hook
  - [ ] 添加网络切换逻辑 (Arbitrum Sepolia)
  - [ ] 处理账户变更事件
  - [ ] 实现 EVM 地址与 Cosmos 地址映射

- [ ] Task 2: 开发桥接合约 (AC: 2)
  - [ ] 创建 `BridgeAdapter.sol` (存款/取款方法)
  - [ ] 实现事件监听器 (`DepositEvent`, `WithdrawEvent`)
  - [ ] 配置 USDC 测试代币地址
  - [ ] 部署到 Arbitrum Sepolia

- [ ] Task 3: 链端桥接模块占位 (AC: 5)
  - [ ] 创建 `x/bridge` 模块骨架
  - [ ] 定义存款/取款消息类型
  - [ ] 实现 Keeper 占位方法
  - [ ] 配置 IBC 连接参数

- [ ] Task 4: 前端入出金 UI (AC: 3)
  - [ ] DepositModal - 入金表单
  - [ ] WithdrawModal - 出金表单
  - [ ] BridgeStatus - 桥接状态跟踪
  - [ ] TransactionHistory - 历史记录

- [ ] Task 5: Hardhat 测试环境 (AC: 4)
  - [ ] 配置 Hardhat 项目结构
  - [ ] 编写合约单元测试
  - [ ] 配置 Arbitrum Sepolia 部署脚本
  - [ ] 集成 ethers.js

- [ ] Task 6: 端到端测试 (AC: 5)
  - [ ] 测试入金流程 (Arbitrum → RiverChain)
  - [ ] 测试出金流程 (RiverChain → Arbitrum)
  - [ ] 验证余额同步
  - [ ] 错误场景测试

## Dev Notes

### 桥接架构

```
┌─────────────────┐         ┌─────────────────┐         ┌─────────────────┐
│  Arbitrum       │         │   RiverChain    │         │   Arbitrum      │
│  Sepolia        │         │   (Cosmos SDK)  │         │   Sepolia       │
│                 │         │                 │         │                 │
│  BridgeAdapter  │◄───────►│   x/bridge      │◄───────►│  BridgeAdapter  │
│  (Solidity)     │  事件监听  │   (Go)          │  事件触发  │  (Solidity)     │
│                 │         │                 │         │                 │
│  USDC (ERC20)   │         │  IBC Transfer   │         │  USDC (ERC20)   │
└─────────────────┘         └─────────────────┘         └─────────────────┘
```

[Source: dYdX v4 Bridge Architecture]

### 项目结构

```
arbitrum-bridge/
├── contracts/
│   ├── BridgeAdapter.sol        # 桥接合约
│   ├── interfaces/
│   │   └── IERC20.sol           # ERC20 接口
│   └── mocks/
│       └── MockUSDC.sol         # 测试代币
├── scripts/
│   ├── deploy.ts                # 部署脚本
│   └── verify.ts                # 验证脚本
├── test/
│   ├── BridgeAdapter.test.ts    # 合约测试
│   └── integration.test.ts      # 集成测试
├── hardhat.config.ts            # Hardhat 配置
└── package.json

riverchain/protocol/x/bridge/
├── types/
│   ├── tx.proto                 # 交易消息定义
│   ├── query.proto              # 查询定义
│   └── events.proto             # 事件定义
├── keeper/
│   ├── keeper.go                # Keeper 实现
│   ├── msg_server.go            # 消息处理器
│   └── query_server.go          # 查询处理器
└── client/
    └── cli/                     # CLI 命令
```

[Source: docs/architecture/unified-project-structure.md]

### BridgeAdapter 合约

```solidity
// contracts/BridgeAdapter.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract BridgeAdapter is ReentrancyGuard, Ownable {
    IERC20 public immutable usdc;

    event Deposit(
        address indexed depositor,
        string indexed riverChainAddress,
        uint256 amount,
        uint256 timestamp
    );

    event Withdraw(
        address indexed recipient,
        uint256 amount,
        uint256 timestamp
    );

    constructor(address _usdc) {
        require(_usdc != address(0), "Invalid USDC address");
        usdc = IERC20(_usdc);
    }

    /**
     * @notice 用户从 Arbitrum 入金到 RiverChain
     * @param riverChainAddress 用户的 RiverChain 地址 (bech32 格式)
     * @param amount USDC 金额 (6 位小数)
     */
    function deposit(string calldata riverChainAddress, uint256 amount) external nonReentrant {
        require(amount > 0, "Amount must be greater than 0");
        require(bytes(riverChainAddress).length > 0, "Invalid RiverChain address");

        // 转账 USDC 到合约
        bool success = usdc.transferFrom(msg.sender, address(this), amount);
        require(success, "USDC transfer failed");

        emit Deposit(msg.sender, riverChainAddress, amount, block.timestamp);
    }

    /**
     * @notice 管理员批准从 RiverChain 提款到 Arbitrum
     * @param recipient 接收者地址 (EVM 地址)
     * @param amount USDC 金额
     */
    function withdraw(address recipient, uint256 amount) external onlyOwner nonReentrant {
        require(recipient != address(0), "Invalid recipient");
        require(amount > 0, "Amount must be greater than 0");
        require(usdc.balanceOf(address(this)) >= amount, "Insufficient balance");

        bool success = usdc.transfer(recipient, amount);
        require(success, "USDC transfer failed");

        emit Withdraw(recipient, amount, block.timestamp);
    }

    /**
     * @notice 查询合约 USDC 余额
     */
    function getBalance() external view returns (uint256) {
        return usdc.balanceOf(address(this));
    }
}
```

[Source: OpenZeppelin Contracts]

### Hardhat 配置

```typescript
// hardhat.config.ts
import { HardhatUserConfig } from "hardhat/config";
import "@nomicfoundation/hardhat-toolbox";
import "@nomicfoundation/hardhat-verify";

const config: HardhatUserConfig = {
  solidity: {
    version: "0.8.20",
    settings: {
      optimizer: {
        enabled: true,
        runs: 200,
      },
    },
  },
  networks: {
    arbitrumSepolia: {
      url: process.env.ARBITRUM_SEPOLIA_RPC || "https://sepolia-rollup.arbitrum.io/rpc",
      accounts: process.env.PRIVATE_KEY ? [process.env.PRIVATE_KEY] : [],
      chainId: 421614,
    },
    localhost: {
      url: "http://127.0.0.1:8545",
    },
  },
  etherscan: {
    apiKey: {
      arbitrumSepolia: process.env.ARBISCAN_API_KEY || "",
    },
  },
};

export default config;
```

[Source: Hardhat Documentation]

### 部署脚本

```typescript
// scripts/deploy.ts
import { ethers } from "hardhat";

async function main() {
  // Arbitrum Sepolia USDC 测试代币地址
  const USDC_ADDRESS = "0x75faf114eafb1BDbe2F0316DF893fd58CE46AA4d";

  console.log("Deploying BridgeAdapter...");

  const BridgeAdapter = await ethers.getContractFactory("BridgeAdapter");
  const bridge = await BridgeAdapter.deploy(USDC_ADDRESS);

  await bridge.waitForDeployment();

  const address = await bridge.getAddress();
  console.log("BridgeAdapter deployed to:", address);

  // 验证部署
  console.log("Verifying contract...");
  await run("verify:verify", {
    address: address,
    constructorArguments: [USDC_ADDRESS],
  });
}

main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
```

[Source: Hardhat Deploy Pattern]

### RiverChain 桥接模块 (占位)

```protobuf
// protocol/x/bridge/types/tx.proto
syntax = "proto3";
package riverchain.bridge.v1;

option go_package = "riverchain/x/bridge/types";

service Msg {
  // 处理来自 Arbitrum 的存款
  rpc ProcessDeposit(MsgProcessDeposit) returns (MsgProcessDepositResponse);

  // 发起提款到 Arbitrum
  rpc InitiateWithdrawal(MsgInitiateWithdrawal) returns (MsgInitiateWithdrawalResponse);
}

message MsgProcessDeposit {
  string depositor = 1;              // Arbitrum 地址
  string river_chain_address = 2;    // RiverChain 地址
  string amount = 3;                 // USDC 金额
  string tx_hash = 4;                // Arbitrum 交易哈希
}

message MsgProcessDepositResponse {
  bool success = 1;
}

message MsgInitiateWithdrawal {
  string sender = 1;                 // RiverChain 地址
  string arbitrum_address = 2;       // Arbitrum 接收地址
  string amount = 3;                 // USDC 金额
}

message MsgInitiateWithdrawalResponse {
  string withdrawal_id = 1;
  bool success = 2;
}
```

```go
// protocol/x/bridge/keeper/msg_server.go
package keeper

import (
    "context"

    sdk "github.com/cosmos/cosmos-sdk/types"
    "riverchain/x/bridge/types"
)

type msgServer struct {
    Keeper
}

func NewMsgServerImpl(keeper Keeper) types.MsgServer {
    return &msgServer{Keeper: keeper}
}

func (k msgServer) ProcessDeposit(
    goCtx context.Context,
    msg *types.MsgProcessDeposit,
) (*types.MsgProcessDepositResponse, error) {
    ctx := sdk.UnwrapSDKContext(goCtx)

    // 验证交易哈希
    // TODO: 实现 Arbitrum 交易验证逻辑

    // 铸造 USDC 到 RiverChain 地址
    riverAddr, err := sdk.AccAddressFromBech32(msg.RiverChainAddress)
    if err != nil {
        return nil, err
    }

    amount, ok := sdk.NewIntFromString(msg.Amount)
    if !ok {
        return nil, types.ErrInvalidAmount
    }

    coins := sdk.NewCoins(sdk.NewCoin("usdc", amount))

    // TODO: 实际铸造逻辑
    // k.bankKeeper.MintCoins(ctx, types.ModuleName, coins)
    // k.bankKeeper.SendCoinsFromModuleToAccount(ctx, types.ModuleName, riverAddr, coins)

    ctx.EventManager().EmitEvent(
        sdk.NewEvent(
            types.EventTypeDeposit,
            sdk.NewAttribute(types.AttributeKeyDepositor, msg.Depositor),
            sdk.NewAttribute(types.AttributeKeyAmount, msg.Amount),
        ),
    )

    return &types.MsgProcessDepositResponse{Success: true}, nil
}

func (k msgServer) InitiateWithdrawal(
    goCtx context.Context,
    msg *types.MsgInitiateWithdrawal,
) (*types.MsgInitiateWithdrawalResponse, error) {
    ctx := sdk.UnwrapSDKContext(goCtx)

    // 验证用户余额
    sender, err := sdk.AccAddressFromBech32(msg.Sender)
    if err != nil {
        return nil, err
    }

    amount, ok := sdk.NewIntFromString(msg.Amount)
    if !ok {
        return nil, types.ErrInvalidAmount
    }

    coins := sdk.NewCoins(sdk.NewCoin("usdc", amount))

    // 扣除用户余额
    // TODO: 实际销毁逻辑
    // k.bankKeeper.SendCoinsFromAccountToModule(ctx, sender, types.ModuleName, coins)
    // k.bankKeeper.BurnCoins(ctx, types.ModuleName, coins)

    // 创建提款记录
    withdrawalId := k.GenerateWithdrawalId(ctx)

    ctx.EventManager().EmitEvent(
        sdk.NewEvent(
            types.EventTypeWithdrawal,
            sdk.NewAttribute(types.AttributeKeySender, msg.Sender),
            sdk.NewAttribute(types.AttributeKeyRecipient, msg.ArbitrumAddress),
            sdk.NewAttribute(types.AttributeKeyAmount, msg.Amount),
            sdk.NewAttribute(types.AttributeKeyWithdrawalId, withdrawalId),
        ),
    )

    return &types.MsgInitiateWithdrawalResponse{
        WithdrawalId: withdrawalId,
        Success:      true,
    }, nil
}
```

[Source: Cosmos SDK Module Pattern]

### MetaMask Hook

```typescript
// src/hooks/useMetaMask.ts
import { useState, useEffect } from 'react';
import { ethers } from 'ethers';

const ARBITRUM_SEPOLIA_CHAIN_ID = '0x66eee'; // 421614 in hex

interface MetaMaskState {
  provider: ethers.BrowserProvider | null;
  account: string | null;
  chainId: string | null;
  isConnected: boolean;
  isLoading: boolean;
  error: Error | null;
}

export function useMetaMask() {
  const [state, setState] = useState<MetaMaskState>({
    provider: null,
    account: null,
    chainId: null,
    isConnected: false,
    isLoading: false,
    error: null,
  });

  const connect = async () => {
    setState(prev => ({ ...prev, isLoading: true, error: null }));

    try {
      if (!window.ethereum) {
        throw new Error('MetaMask not installed');
      }

      const provider = new ethers.BrowserProvider(window.ethereum);

      // 请求账户访问
      const accounts = await provider.send('eth_requestAccounts', []);
      const account = accounts[0];

      // 获取链 ID
      const network = await provider.getNetwork();
      const chainId = `0x${network.chainId.toString(16)}`;

      // 切换到 Arbitrum Sepolia
      if (chainId !== ARBITRUM_SEPOLIA_CHAIN_ID) {
        await switchToArbitrumSepolia();
      }

      setState({
        provider,
        account,
        chainId: ARBITRUM_SEPOLIA_CHAIN_ID,
        isConnected: true,
        isLoading: false,
        error: null,
      });
    } catch (error) {
      setState(prev => ({
        ...prev,
        isLoading: false,
        error: error as Error,
      }));
    }
  };

  const switchToArbitrumSepolia = async () => {
    try {
      await window.ethereum.request({
        method: 'wallet_switchEthereumChain',
        params: [{ chainId: ARBITRUM_SEPOLIA_CHAIN_ID }],
      });
    } catch (switchError: any) {
      // Chain not added, add it
      if (switchError.code === 4902) {
        await window.ethereum.request({
          method: 'wallet_addEthereumChain',
          params: [
            {
              chainId: ARBITRUM_SEPOLIA_CHAIN_ID,
              chainName: 'Arbitrum Sepolia',
              nativeCurrency: {
                name: 'ETH',
                symbol: 'ETH',
                decimals: 18,
              },
              rpcUrls: ['https://sepolia-rollup.arbitrum.io/rpc'],
              blockExplorerUrls: ['https://sepolia.arbiscan.io/'],
            },
          ],
        });
      } else {
        throw switchError;
      }
    }
  };

  const disconnect = () => {
    setState({
      provider: null,
      account: null,
      chainId: null,
      isConnected: false,
      isLoading: false,
      error: null,
    });
  };

  // 监听账户和网络变更
  useEffect(() => {
    if (!window.ethereum) return;

    const handleAccountsChanged = (accounts: string[]) => {
      if (accounts.length > 0) {
        setState(prev => ({ ...prev, account: accounts[0] }));
      } else {
        disconnect();
      }
    };

    const handleChainChanged = (chainId: string) => {
      setState(prev => ({ ...prev, chainId }));
    };

    window.ethereum.on('accountsChanged', handleAccountsChanged);
    window.ethereum.on('chainChanged', handleChainChanged);

    return () => {
      window.ethereum.removeListener('accountsChanged', handleAccountsChanged);
      window.ethereum.removeListener('chainChanged', handleChainChanged);
    };
  }, []);

  return {
    ...state,
    connect,
    disconnect,
  };
}
```

[Source: MetaMask Documentation]

### 入出金 UI 组件

```typescript
// src/components/bridge/DepositModal.tsx
import { useState } from 'react';
import { useMetaMask } from '../../hooks/useMetaMask';
import { useRiverChain } from '../../contexts/RiverChainContext';
import { ethers } from 'ethers';

const BRIDGE_CONTRACT_ADDRESS = '0x...'; // 部署后填写
const USDC_ADDRESS = '0x75faf114eafb1BDbe2F0316DF893fd58CE46AA4d';

export default function DepositModal({ isOpen, onClose }: { isOpen: boolean; onClose: () => void }) {
  const { provider, account } = useMetaMask();
  const { address: riverAddress } = useRiverChain();
  const [amount, setAmount] = useState('');
  const [loading, setLoading] = useState(false);

  const handleDeposit = async () => {
    if (!provider || !account || !riverAddress) return;

    setLoading(true);
    try {
      const signer = await provider.getSigner();

      // USDC 合约
      const usdcAbi = ['function approve(address spender, uint256 amount) returns (bool)'];
      const usdc = new ethers.Contract(USDC_ADDRESS, usdcAbi, signer);

      // 授权 Bridge 合约
      const amountWei = ethers.parseUnits(amount, 6); // USDC 6 位小数
      const approveTx = await usdc.approve(BRIDGE_CONTRACT_ADDRESS, amountWei);
      await approveTx.wait();

      // Bridge 合约
      const bridgeAbi = ['function deposit(string riverChainAddress, uint256 amount)'];
      const bridge = new ethers.Contract(BRIDGE_CONTRACT_ADDRESS, bridgeAbi, signer);

      const depositTx = await bridge.deposit(riverAddress, amountWei);
      await depositTx.wait();

      alert('Deposit successful!');
      onClose();
    } catch (error) {
      console.error('Deposit failed:', error);
      alert('Deposit failed');
    } finally {
      setLoading(false);
    }
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center">
      <div className="bg-gray-800 p-6 rounded-lg w-96">
        <h2 className="text-2xl font-bold mb-4">Deposit USDC</h2>

        <div className="mb-4">
          <label className="block text-sm text-gray-400 mb-2">Amount</label>
          <input
            type="number"
            value={amount}
            onChange={(e) => setAmount(e.target.value)}
            className="w-full px-3 py-2 bg-gray-700 rounded"
            placeholder="0.00"
          />
        </div>

        <div className="mb-4">
          <div className="text-sm text-gray-400">RiverChain Address</div>
          <div className="text-sm">{riverAddress}</div>
        </div>

        <div className="flex space-x-2">
          <button
            onClick={handleDeposit}
            disabled={loading || !amount}
            className="flex-1 px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded disabled:opacity-50"
          >
            {loading ? 'Processing...' : 'Deposit'}
          </button>
          <button
            onClick={onClose}
            className="flex-1 px-4 py-2 bg-gray-600 hover:bg-gray-700 rounded"
          >
            Cancel
          </button>
        </div>
      </div>
    </div>
  );
}
```

```typescript
// src/components/bridge/WithdrawModal.tsx
import { useState } from 'react';
import { useRiverChain } from '../../contexts/RiverChainContext';
import { useMetaMask } from '../../hooks/useMetaMask';

export default function WithdrawModal({ isOpen, onClose }: { isOpen: boolean; onClose: () => void }) {
  const { client, address: riverAddress } = useRiverChain();
  const { account: evmAddress } = useMetaMask();
  const [amount, setAmount] = useState('');
  const [loading, setLoading] = useState(false);

  const handleWithdraw = async () => {
    if (!client || !riverAddress || !evmAddress) return;

    setLoading(true);
    try {
      // 调用 RiverChain 提款消息
      const msg = {
        typeUrl: '/riverchain.bridge.v1.MsgInitiateWithdrawal',
        value: {
          sender: riverAddress,
          arbitrumAddress: evmAddress,
          amount: (parseFloat(amount) * 1_000_000).toString(), // 转换为 6 位小数
        },
      };

      // TODO: 实现消息发送
      // const result = await client.signAndBroadcast(riverAddress, [msg], 'auto');

      alert('Withdrawal initiated!');
      onClose();
    } catch (error) {
      console.error('Withdrawal failed:', error);
      alert('Withdrawal failed');
    } finally {
      setLoading(false);
    }
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center">
      <div className="bg-gray-800 p-6 rounded-lg w-96">
        <h2 className="text-2xl font-bold mb-4">Withdraw USDC</h2>

        <div className="mb-4">
          <label className="block text-sm text-gray-400 mb-2">Amount</label>
          <input
            type="number"
            value={amount}
            onChange={(e) => setAmount(e.target.value)}
            className="w-full px-3 py-2 bg-gray-700 rounded"
            placeholder="0.00"
          />
        </div>

        <div className="mb-4">
          <div className="text-sm text-gray-400">Arbitrum Address</div>
          <div className="text-sm">{evmAddress}</div>
        </div>

        <div className="flex space-x-2">
          <button
            onClick={handleWithdraw}
            disabled={loading || !amount}
            className="flex-1 px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded disabled:opacity-50"
          >
            {loading ? 'Processing...' : 'Withdraw'}
          </button>
          <button
            onClick={onClose}
            className="flex-1 px-4 py-2 bg-gray-600 hover:bg-gray-700 rounded"
          >
            Cancel
          </button>
        </div>
      </div>
    </div>
  );
}
```

[Source: Story 1.6 Requirements]

### 合约测试

```typescript
// test/BridgeAdapter.test.ts
import { expect } from "chai";
import { ethers } from "hardhat";
import { BridgeAdapter, MockUSDC } from "../typechain-types";
import { SignerWithAddress } from "@nomicfoundation/hardhat-ethers/signers";

describe("BridgeAdapter", function () {
  let bridge: BridgeAdapter;
  let usdc: MockUSDC;
  let owner: SignerWithAddress;
  let user: SignerWithAddress;

  beforeEach(async () => {
    [owner, user] = await ethers.getSigners();

    // 部署 Mock USDC
    const MockUSDC = await ethers.getContractFactory("MockUSDC");
    usdc = await MockUSDC.deploy();

    // 部署 BridgeAdapter
    const BridgeAdapter = await ethers.getContractFactory("BridgeAdapter");
    bridge = await BridgeAdapter.deploy(await usdc.getAddress());

    // 给用户铸造 USDC
    await usdc.mint(user.address, ethers.parseUnits("1000", 6));
  });

  describe("Deposit", () => {
    it("should accept USDC deposits", async () => {
      const amount = ethers.parseUnits("100", 6);
      const riverAddress = "river1abcdef...";

      // 授权
      await usdc.connect(user).approve(await bridge.getAddress(), amount);

      // 存款
      await expect(bridge.connect(user).deposit(riverAddress, amount))
        .to.emit(bridge, "Deposit")
        .withArgs(user.address, riverAddress, amount, anyValue);

      // 验证合约余额
      expect(await bridge.getBalance()).to.equal(amount);
    });

    it("should reject zero amount", async () => {
      await expect(
        bridge.connect(user).deposit("river1abc...", 0)
      ).to.be.revertedWith("Amount must be greater than 0");
    });

    it("should reject empty RiverChain address", async () => {
      await expect(
        bridge.connect(user).deposit("", ethers.parseUnits("100", 6))
      ).to.be.revertedWith("Invalid RiverChain address");
    });
  });

  describe("Withdraw", () => {
    beforeEach(async () => {
      const amount = ethers.parseUnits("100", 6);
      await usdc.connect(user).approve(await bridge.getAddress(), amount);
      await bridge.connect(user).deposit("river1abc...", amount);
    });

    it("should allow owner to withdraw", async () => {
      const amount = ethers.parseUnits("50", 6);

      await expect(bridge.connect(owner).withdraw(user.address, amount))
        .to.emit(bridge, "Withdraw")
        .withArgs(user.address, amount, anyValue);

      expect(await usdc.balanceOf(user.address)).to.equal(
        ethers.parseUnits("950", 6) // 1000 - 100 + 50
      );
    });

    it("should reject non-owner withdrawal", async () => {
      await expect(
        bridge.connect(user).withdraw(user.address, ethers.parseUnits("50", 6))
      ).to.be.revertedWith("Ownable: caller is not the owner");
    });
  });
});
```

[Source: Hardhat Testing Guide]

### 依赖安装

```json
// arbitrum-bridge/package.json
{
  "name": "arbitrum-bridge",
  "version": "1.0.0",
  "devDependencies": {
    "@nomicfoundation/hardhat-toolbox": "^4.0.0",
    "@nomicfoundation/hardhat-verify": "^2.0.0",
    "@openzeppelin/contracts": "^5.0.0",
    "hardhat": "^2.19.0",
    "ethers": "^6.9.0"
  },
  "scripts": {
    "compile": "hardhat compile",
    "test": "hardhat test",
    "deploy:sepolia": "hardhat run scripts/deploy.ts --network arbitrumSepolia"
  }
}
```

安装命令:
```bash
cd arbitrum-bridge
npm install
```

[Source: docs/architecture/tech-stack.md]

### 环境变量配置

```bash
# .env
ARBITRUM_SEPOLIA_RPC=https://sepolia-rollup.arbitrum.io/rpc
PRIVATE_KEY=your_private_key_here
ARBISCAN_API_KEY=your_arbiscan_api_key
```

### 部署与验证

```bash
# 编译合约
npm run compile

# 运行测试
npm test

# 部署到 Arbitrum Sepolia
npm run deploy:sepolia

# 输出示例:
# Deploying BridgeAdapter...
# BridgeAdapter deployed to: 0x1234567890abcdef...
# Verifying contract...
# Successfully verified contract BridgeAdapter
```

[Source: Hardhat Deployment Guide]

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-04 | 1.0 | Initial story creation | Scrum Master Bob |
| 2025-10-04 | 1.1 | Ready for implementation | Dev Agent James |

## Dev Agent Record

### Agent Model Used
Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)

### Implementation Artifacts
- BridgeAdapter.sol 完整实现
- Hardhat 测试框架配置
- MetaMask Hook 实现
- 入出金 UI 组件
- x/bridge 模块占位代码

### File List
- Solidity 合约代码已嵌入文档
- Hardhat 配置与测试已提供
- 前端 Hook 和组件已包含
- 链端模块骨架已定义

## QA Results
_待 QA 代理填写_
