# Story 1.4: Streaming与Indexer基础配置

## Status
Approved

## Story
**As a** 后端开发者,
**I want** 启用 Full Node Streaming 并配置 Indexer,
**so that** 实时订阅链上事件并提供历史数据查询。

## Acceptance Criteria
1. `protocol/streaming/full_node_streaming_manager.go` - 启用订阅功能
2. `protocol/indexer/*` - PostgreSQL 连接配置完成
3. 本地 PostgreSQL 15+ 数据库启动
4. Indexer 守护进程成功运行并索引创世区块
5. WebSocket 接口可访问 (localhost:8080/streaming)

## Tasks / Subtasks

- [ ] Task 1: 启用 Full Node Streaming (AC: 1)
  - [ ] 修改 `full_node_streaming_manager.go` 启用 Streaming
  - [ ] 配置订阅事件类型 (订单、成交、仓位)
  - [ ] 设置 WebSocket 服务端口

- [ ] Task 2: 配置 PostgreSQL 数据库 (AC: 2, 3)
  - [ ] 启动 PostgreSQL 15+ (Docker 或本地安装)
  - [ ] 创建数据库: `riverchain_indexer`
  - [ ] 创建用户与权限配置
  - [ ] 初始化数据库 schema

- [ ] Task 3: 配置 Indexer 连接 (AC: 2)
  - [ ] 编辑 `protocol/indexer/postgres/config.go`
  - [ ] 设置数据库连接字符串
  - [ ] 配置连接池参数

- [ ] Task 4: 实现事件索引 (AC: 4)
  - [ ] 索引 `OrderPlaced` 事件
  - [ ] 索引 `OrderMatched` 事件
  - [ ] 索引 `OrderCanceled` 事件
  - [ ] 索引 `PositionUpdated` 事件

- [ ] Task 5: 启动 Indexer 守护进程 (AC: 4)
  - [ ] 编译 Indexer: `make build-indexer`
  - [ ] 启动守护进程
  - [ ] 验证创世区块索引

- [ ] Task 6: 测试 WebSocket 接口 (AC: 5)
  - [ ] 使用 wscat 测试连接
  - [ ] 订阅订单簿数据
  - [ ] 验证实时更新

## Dev Notes

### Streaming 架构

```
                    ┌─────────────┐
                    │  RiverChain │
                    │    Node     │
                    └──────┬──────┘
                           │
                    ┌──────▼──────┐
                    │  Streaming  │
                    │   Manager   │
                    └──────┬──────┘
                           │
              ┌────────────┴────────────┐
              │                         │
       ┌──────▼──────┐         ┌───────▼────────┐
       │  WebSocket  │         │  gRPC Stream   │
       │   Server    │         │    Server      │
       └──────┬──────┘         └───────┬────────┘
              │                         │
       ┌──────▼──────┐         ┌───────▼────────┐
       │   Frontend  │         │    Indexer     │
       │   Clients   │         │   (PostgreSQL) │
       └─────────────┘         └────────────────┘
```

[Source: dYdX v4 Streaming Architecture]

### Full Node Streaming 配置

#### 启用 Streaming
```go
// protocol/streaming/full_node_streaming_manager.go

type StreamingConfig struct {
    Enabled       bool
    WebSocketPort int
    BufferSize    int
    EventTypes    []string
}

var DefaultStreamingConfig = StreamingConfig{
    Enabled:       true,
    WebSocketPort: 8080,
    BufferSize:    1000,
    EventTypes: []string{
        "order_placed",
        "order_matched",
        "order_canceled",
        "position_updated",
        "funding_payment",
    },
}
```

#### WebSocket 服务
```go
func (m *FullNodeStreamingManager) StartWebSocketServer() error {
    http.HandleFunc("/streaming", m.handleWebSocket)

    addr := fmt.Sprintf(":%d", m.config.WebSocketPort)
    log.Printf("Starting WebSocket server on %s", addr)

    return http.ListenAndServe(addr, nil)
}

func (m *FullNodeStreamingManager) handleWebSocket(w http.ResponseWriter, r *http.Request) {
    conn, err := upgrader.Upgrade(w, r, nil)
    if err != nil {
        log.Printf("WebSocket upgrade error: %v", err)
        return
    }
    defer conn.Close()

    // 订阅事件流
    eventChan := m.Subscribe()
    for event := range eventChan {
        if err := conn.WriteJSON(event); err != nil {
            log.Printf("Write error: %v", err)
            break
        }
    }
}
```

[Source: dYdX v4 Streaming Implementation]

### PostgreSQL 配置

#### Docker Compose 配置
```yaml
# docker-compose.yml
version: '3.8'

services:
  postgres:
    image: postgres:15-alpine
    container_name: riverchain-postgres
    environment:
      POSTGRES_DB: riverchain_indexer
      POSTGRES_USER: riverchain
      POSTGRES_PASSWORD: riverchain_pass
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./indexer/schema:/docker-entrypoint-initdb.d

volumes:
  postgres_data:
```

#### 数据库 Schema
```sql
-- indexer/schema/001_init.sql

CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    order_id VARCHAR(64) UNIQUE NOT NULL,
    subaccount_id VARCHAR(64) NOT NULL,
    market VARCHAR(32) NOT NULL,
    side VARCHAR(4) NOT NULL,
    price DECIMAL(20,6) NOT NULL,
    size DECIMAL(20,6) NOT NULL,
    status VARCHAR(16) NOT NULL,
    created_at TIMESTAMP NOT NULL,
    updated_at TIMESTAMP NOT NULL
);

CREATE INDEX idx_orders_subaccount ON orders(subaccount_id);
CREATE INDEX idx_orders_market ON orders(market);
CREATE INDEX idx_orders_status ON orders(status);

CREATE TABLE trades (
    id SERIAL PRIMARY KEY,
    trade_id VARCHAR(64) UNIQUE NOT NULL,
    maker_order_id VARCHAR(64) NOT NULL,
    taker_order_id VARCHAR(64) NOT NULL,
    market VARCHAR(32) NOT NULL,
    price DECIMAL(20,6) NOT NULL,
    size DECIMAL(20,6) NOT NULL,
    created_at TIMESTAMP NOT NULL
);

CREATE INDEX idx_trades_market ON trades(market);
CREATE INDEX idx_trades_created_at ON trades(created_at);

CREATE TABLE positions (
    id SERIAL PRIMARY KEY,
    subaccount_id VARCHAR(64) NOT NULL,
    market VARCHAR(32) NOT NULL,
    size DECIMAL(20,6) NOT NULL,
    entry_price DECIMAL(20,6) NOT NULL,
    unrealized_pnl DECIMAL(20,6),
    updated_at TIMESTAMP NOT NULL,
    UNIQUE(subaccount_id, market)
);

CREATE INDEX idx_positions_subaccount ON positions(subaccount_id);
```

[Source: dYdX Indexer Database Schema]

### Indexer 配置

#### 连接配置
```go
// protocol/indexer/postgres/config.go

type PostgresConfig struct {
    Host     string
    Port     int
    Database string
    User     string
    Password string
    SSLMode  string
}

var DefaultPostgresConfig = PostgresConfig{
    Host:     "localhost",
    Port:     5432,
    Database: "riverchain_indexer",
    User:     "riverchain",
    Password: "riverchain_pass",
    SSLMode:  "disable",
}

func (c *PostgresConfig) ConnectionString() string {
    return fmt.Sprintf(
        "host=%s port=%d user=%s password=%s dbname=%s sslmode=%s",
        c.Host, c.Port, c.User, c.Password, c.Database, c.SSLMode,
    )
}
```

#### 事件处理器
```go
// protocol/indexer/events/handler.go

type EventHandler struct {
    db *sql.DB
}

func (h *EventHandler) HandleOrderPlaced(event OrderPlacedEvent) error {
    query := `
        INSERT INTO orders (order_id, subaccount_id, market, side, price, size, status, created_at, updated_at)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
    `

    _, err := h.db.Exec(query,
        event.OrderId,
        event.SubaccountId,
        event.Market,
        event.Side,
        event.Price,
        event.Size,
        "ACTIVE",
        event.Timestamp,
        event.Timestamp,
    )

    return err
}

func (h *EventHandler) HandleOrderMatched(event OrderMatchedEvent) error {
    // 1. 更新订单状态
    // 2. 插入成交记录
    // 3. 更新仓位
    return nil
}
```

[Source: Cosmos SDK Event Indexer Pattern]

### 启动流程

#### 1. 启动 PostgreSQL
```bash
# 使用 Docker Compose
docker-compose up -d postgres

# 验证
docker ps | grep postgres
psql -h localhost -U riverchain -d riverchain_indexer -c "\dt"
```

#### 2. 启动 Indexer
```bash
# 编译
cd protocol
make build-indexer

# 启动
./build/riverchain-indexer \
  --postgres-host=localhost \
  --postgres-port=5432 \
  --postgres-db=riverchain_indexer \
  --postgres-user=riverchain \
  --postgres-password=riverchain_pass \
  --rpc-endpoint=http://localhost:26657

# 后台运行
nohup ./build/riverchain-indexer > indexer.log 2>&1 &
```

#### 3. 启动 Streaming (包含在节点中)
```bash
# 在 app.toml 中配置
[streaming]
enabled = true
websocket_port = 8080
buffer_size = 1000

# 启动节点时自动启用 Streaming
riverchaind start
```

### WebSocket 测试

#### 使用 wscat
```bash
# 安装 wscat
npm install -g wscat

# 连接
wscat -c ws://localhost:8080/streaming

# 订阅订单簿
> {"type": "subscribe", "channel": "orderbook", "market": "BTC-PERP"}

# 接收数据
< {"type":"orderbook","market":"BTC-PERP","bids":[[50000,0.5]],"asks":[[50100,0.3]]}
```

#### 使用 JavaScript
```javascript
const ws = new WebSocket('ws://localhost:8080/streaming');

ws.onopen = () => {
  ws.send(JSON.stringify({
    type: 'subscribe',
    channel: 'orderbook',
    market: 'BTC-PERP'
  }));
};

ws.onmessage = (event) => {
  const data = JSON.parse(event.data);
  console.log('Orderbook update:', data);
};
```

[Source: WebSocket API Best Practices]

### 监控与日志

#### 查看 Indexer 日志
```bash
# 实时查看
tail -f indexer.log

# 搜索错误
grep ERROR indexer.log

# 统计索引进度
grep "Indexed block" indexer.log | tail -5
```

#### 查询索引数据
```sql
-- 检查订单数量
SELECT COUNT(*) FROM orders;

-- 查看最近成交
SELECT * FROM trades ORDER BY created_at DESC LIMIT 10;

-- 检查仓位
SELECT * FROM positions;
```

### Testing

#### 单元测试
```go
// protocol/indexer/events/handler_test.go
func TestHandleOrderPlaced(t *testing.T) {
    db := setupTestDB(t)
    defer db.Close()

    handler := NewEventHandler(db)

    event := OrderPlacedEvent{
        OrderId:      "order-1",
        SubaccountId: "subaccount-1",
        Market:       "BTC-PERP",
        Side:         "BUY",
        Price:        sdk.NewDec(50000),
        Size:         sdk.NewDec(1),
        Timestamp:    time.Now(),
    }

    err := handler.HandleOrderPlaced(event)
    require.NoError(t, err)

    // 验证数据已插入
    var count int
    db.QueryRow("SELECT COUNT(*) FROM orders WHERE order_id = $1", "order-1").Scan(&count)
    require.Equal(t, 1, count)
}
```

#### 集成测试
```bash
# 1. 启动节点和 Indexer
riverchaind start &
riverchain-indexer &

# 2. 下单
riverchaind tx clob place-order \
  --market BTC-PERP \
  --side BUY \
  --price 50000 \
  --size 0.1 \
  --from validator

# 3. 验证索引
sleep 2
psql -h localhost -U riverchain -d riverchain_indexer \
  -c "SELECT * FROM orders WHERE market='BTC-PERP';"
```

**覆盖率要求**: > 75%

[Source: docs/architecture/testing-strategy.md]

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-04 | 1.0 | Initial story creation | Scrum Master Bob |
| 2025-10-04 | 1.1 | Ready for implementation | Dev Agent James |

## Dev Agent Record

### Agent Model Used
Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)

### Implementation Artifacts
- Docker Compose 配置模板
- PostgreSQL Schema 脚本
- Indexer 配置示例
- WebSocket 测试脚本

### File List
- `docker-compose.yml` - PostgreSQL 容器配置
- `indexer/schema/001_init.sql` - 数据库 Schema
- WebSocket 测试示例 (已嵌入文档)

## QA Results
_待 QA 代理填写_
