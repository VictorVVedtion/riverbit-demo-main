# Story 3.1: 推荐码生成与绑定

## Status
Approved

## Story
**As a** RiverBit 用户,
**I want** 生成专属推荐码并邀请新用户,
**so that** 可以建立推荐关系并获得分润收益。

## Acceptance Criteria
1. 用户可生成唯一推荐码 (8 位字母数字,大写)
2. 新用户通过推荐码 URL 注册并自动绑定关系
3. 推荐关系写入链上 (x/affiliates 模块)
4. 支持查询推荐关系树 (最多 3 层)
5. 防止循环推荐和重复绑定

## Tasks / Subtasks

- [ ] Task 1: 推荐码生成 (AC: 1)
  - [ ] 生成算法 (base32 编码)
  - [ ] 唯一性验证
  - [ ] 链上存储

- [ ] Task 2: 推荐关系绑定 (AC: 2, 3)
  - [ ] MsgRegisterAffiliate 消息
  - [ ] 推荐关系验证
  - [ ] 链上写入

- [ ] Task 3: 关系查询 (AC: 4)
  - [ ] 查询上级推荐人
  - [ ] 查询下级被推荐人
  - [ ] 推荐树构建

- [ ] Task 4: 循环检测 (AC: 5)
  - [ ] 循环推荐检测算法
  - [ ] 重复绑定校验

- [ ] Task 5: 前端集成
  - [ ] useReferralCode Hook
  - [ ] 推荐码展示和复制
  - [ ] 邀请链接生成

## Dev Notes

### 推荐码生成 (链端)

```go
// protocol/x/affiliates/keeper/referral_code.go
package keeper

import (
    "crypto/rand"
    "encoding/base32"
    "strings"
)

func (k Keeper) GenerateReferralCode(ctx sdk.Context, address string) (string, error) {
    // 生成 5 字节随机数
    bytes := make([]byte, 5)
    if _, err := rand.Read(bytes); err != nil {
        return "", err
    }

    // Base32 编码 → 8 字符
    code := strings.ToUpper(
        base32.StdEncoding.EncodeToString(bytes)[:8],
    )

    // 检查唯一性
    if k.CodeExists(ctx, code) {
        return k.GenerateReferralCode(ctx, address) // 递归重试
    }

    // 存储映射
    k.SetReferralCode(ctx, address, code)
    k.SetCodeOwner(ctx, code, address)

    return code, nil
}

func (k Keeper) CodeExists(ctx sdk.Context, code string) bool {
    store := ctx.KVStore(k.storeKey)
    key := types.CodeOwnerKey(code)
    return store.Has(key)
}
```

[Source: Base32 Encoding Pattern]

### 推荐关系消息

```protobuf
// protocol/x/affiliates/types/tx.proto
syntax = "proto3";

service Msg {
  rpc RegisterAffiliate(MsgRegisterAffiliate) returns (MsgRegisterAffiliateResponse);
}

message MsgRegisterAffiliate {
  string user_address = 1;        // 新用户地址
  string referral_code = 2;       // 推荐码
}

message MsgRegisterAffiliateResponse {
  bool success = 1;
  string referrer_address = 2;   // 推荐人地址
}
```

```go
// protocol/x/affiliates/keeper/msg_server.go
func (k msgServer) RegisterAffiliate(
    goCtx context.Context,
    msg *types.MsgRegisterAffiliate,
) (*types.MsgRegisterAffiliateResponse, error) {
    ctx := sdk.UnwrapSDKContext(goCtx)

    // 1. 验证推荐码存在
    referrerAddr := k.GetCodeOwner(ctx, msg.ReferralCode)
    if referrerAddr == "" {
        return nil, types.ErrInvalidReferralCode
    }

    // 2. 检查是否已绑定
    if k.HasReferrer(ctx, msg.UserAddress) {
        return nil, types.ErrAlreadyReferred
    }

    // 3. 检查循环推荐
    if k.IsCircularReference(ctx, msg.UserAddress, referrerAddr) {
        return nil, types.ErrCircularReference
    }

    // 4. 建立推荐关系
    k.SetReferrer(ctx, msg.UserAddress, referrerAddr)

    // 5. 发出事件
    ctx.EventManager().EmitEvent(
        sdk.NewEvent(
            types.EventTypeAffiliateRegistered,
            sdk.NewAttribute(types.AttributeKeyUser, msg.UserAddress),
            sdk.NewAttribute(types.AttributeKeyReferrer, referrerAddr),
        ),
    )

    return &types.MsgRegisterAffiliateResponse{
        Success:         true,
        ReferrerAddress: referrerAddr,
    }, nil
}

// 循环推荐检测
func (k Keeper) IsCircularReference(ctx sdk.Context, user, referrer string) bool {
    current := referrer
    for i := 0; i < 10; i++ { // 最多检查 10 层
        if current == user {
            return true // 检测到循环
        }
        parent := k.GetReferrer(ctx, current)
        if parent == "" {
            break
        }
        current = parent
    }
    return false
}
```

[Source: Graph Cycle Detection]

### 推荐关系查询

```go
// protocol/x/affiliates/keeper/query_server.go
func (k Keeper) ReferralTree(
    ctx context.Context,
    req *types.QueryReferralTreeRequest,
) (*types.QueryReferralTreeResponse, error) {
    sdkCtx := sdk.UnwrapSDKContext(ctx)

    tree := k.BuildReferralTree(sdkCtx, req.Address, 3) // 最多 3 层

    return &types.QueryReferralTreeResponse{
        Tree: tree,
    }, nil
}

type ReferralNode struct {
    Address  string
    Code     string
    Level    int
    Children []*ReferralNode
}

func (k Keeper) BuildReferralTree(
    ctx sdk.Context,
    address string,
    maxDepth int,
) *ReferralNode {
    if maxDepth == 0 {
        return nil
    }

    node := &ReferralNode{
        Address:  address,
        Code:     k.GetReferralCode(ctx, address),
        Children: []*ReferralNode{},
    }

    // 查询所有被推荐人
    referees := k.GetReferees(ctx, address)
    for _, referee := range referees {
        child := k.BuildReferralTree(ctx, referee, maxDepth-1)
        if child != nil {
            child.Level = 3 - maxDepth + 1
            node.Children = append(node.Children, child)
        }
    }

    return node
}
```

[Source: Tree Traversal Pattern]

### 前端 Hook

```typescript
// src/hooks/useReferralCode.ts
import { useState, useEffect } from 'react';
import { useRiverChain } from '../contexts/RiverChainContext';

export function useReferralCode() {
  const { client, address } = useRiverChain();
  const [code, setCode] = useState<string | null>(null);
  const [isGenerating, setIsGenerating] = useState(false);

  useEffect(() => {
    if (!client || !address) return;

    // 查询现有推荐码
    client.query('/riverchain.affiliates.v1.Query/ReferralCode', {
      address,
    }).then(res => {
      setCode(res.code);
    }).catch(() => {
      setCode(null);
    });
  }, [client, address]);

  const generateCode = async () => {
    if (!client || !address) return;

    setIsGenerating(true);
    try {
      const msg = {
        typeUrl: '/riverchain.affiliates.v1.MsgGenerateCode',
        value: { address },
      };

      const result = await client.signAndBroadcast(address, [msg], 'auto');

      // 从事件中提取推荐码
      const event = result.events?.find(e => e.type === 'code_generated');
      const newCode = event?.attributes.find(a => a.key === 'code')?.value;

      if (newCode) {
        setCode(newCode);
      }
    } catch (err) {
      console.error('Generate code error:', err);
    } finally {
      setIsGenerating(false);
    }
  };

  const inviteLink = code
    ? `${window.location.origin}/?ref=${code}`
    : null;

  return {
    code,
    inviteLink,
    generateCode,
    isGenerating,
  };
}

// 注册推荐关系
export function useRegisterReferral() {
  const { client, address } = useRiverChain();

  const registerReferral = async (referralCode: string) => {
    if (!client || !address) return false;

    try {
      const msg = {
        typeUrl: '/riverchain.affiliates.v1.MsgRegisterAffiliate',
        value: {
          userAddress: address,
          referralCode,
        },
      };

      const result = await client.signAndBroadcast(address, [msg], 'auto');
      return result.code === 0;
    } catch (err) {
      console.error('Register referral error:', err);
      return false;
    }
  };

  return { registerReferral };
}
```

### 推荐码组件

```typescript
// src/components/referral/ReferralCode.tsx
import { useReferralCode } from '../../hooks/useReferralCode';
import { useState } from 'react';

export default function ReferralCode() {
  const { code, inviteLink, generateCode, isGenerating } = useReferralCode();
  const [copied, setCopied] = useState(false);

  const handleCopy = async (text: string) => {
    await navigator.clipboard.writeText(text);
    setCopied(true);
    setTimeout(() => setCopied(false), 2000);
  };

  if (!code) {
    return (
      <div className="p-6 bg-gray-800 rounded-lg">
        <h3 className="text-xl font-bold mb-4">生成推荐码</h3>
        <p className="text-gray-400 mb-4">
          生成你的专属推荐码,邀请好友交易并获得分润收益
        </p>
        <button
          onClick={generateCode}
          disabled={isGenerating}
          className="px-6 py-3 bg-blue-600 hover:bg-blue-700 rounded-lg font-semibold disabled:opacity-50"
        >
          {isGenerating ? '生成中...' : '生成推荐码'}
        </button>
      </div>
    );
  }

  return (
    <div className="p-6 bg-gray-800 rounded-lg">
      <h3 className="text-xl font-bold mb-4">我的推荐码</h3>

      {/* 推荐码 */}
      <div className="mb-4">
        <label className="block text-sm text-gray-400 mb-2">推荐码</label>
        <div className="flex items-center space-x-2">
          <div className="flex-1 px-4 py-3 bg-gray-900 rounded-lg font-mono text-2xl tracking-wider">
            {code}
          </div>
          <button
            onClick={() => handleCopy(code)}
            className="px-4 py-3 bg-blue-600 hover:bg-blue-700 rounded-lg transition-colors"
          >
            {copied ? '已复制' : '复制'}
          </button>
        </div>
      </div>

      {/* 邀请链接 */}
      <div>
        <label className="block text-sm text-gray-400 mb-2">邀请链接</label>
        <div className="flex items-center space-x-2">
          <input
            type="text"
            value={inviteLink || ''}
            readOnly
            className="flex-1 px-4 py-3 bg-gray-900 rounded-lg text-sm"
          />
          <button
            onClick={() => inviteLink && handleCopy(inviteLink)}
            className="px-4 py-3 bg-blue-600 hover:bg-blue-700 rounded-lg transition-colors"
          >
            复制链接
          </button>
        </div>
      </div>
    </div>
  );
}
```

[Source: Story 3.1 Requirements]

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-04 | 1.0 | Initial story creation | Scrum Master Bob |

## QA Results
_待填写_
